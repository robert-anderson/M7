//
// Created by rja on 07/06/2021.
//

#include "gtest/gtest.h"
#include "src/core/util/ForeachVirtual.h"

namespace foreach_virtual_test {
    using namespace foreach_virtual;

    template<size_t nind>
    struct CtndUnrestricted : ctnd::Unrestricted<nind> {
        /**
         * pass status of the test
         */
        bool m_pass = true;
        /**
         * benchmark indices in order in which they should be generated by the loop
         */
        std::vector<ctnd::inds_t<nind>> m_chk_inds;
        /**
         * body call counter
         */
        size_t m_i = 0ul;

        CtndUnrestricted(ctnd::inds_t<nind> shape, std::vector<ctnd::inds_t<nind>> chk_inds) :
                ctnd::Unrestricted<nind>(shape), m_chk_inds(std::move(chk_inds)) {}

        void body(const ctnd::inds_t<nind> &inds) override {
            if (inds != m_chk_inds[m_i++]) m_pass = false;
        }
    };

    template<size_t nind, bool strict = true, bool ascending = true>
    struct CtndOrdered : ctnd::Ordered<nind, strict, ascending> {
        /**
         * pass status of the test
         */
        bool m_pass = true;
        /**
         * benchmark indices in order in which they should be generated by the loop
         */
        std::vector<ctnd::inds_t<nind>> m_chk_inds;
        /**
         * body call counter
         */
        size_t m_i = 0ul;

        CtndOrdered(size_t n, std::vector<ctnd::inds_t<nind>> chk_inds) :
                ctnd::Ordered<nind, strict, ascending>(n), m_chk_inds(std::move(chk_inds)) {}

        void body(const ctnd::inds_t<nind> &inds) override {
            if (inds != m_chk_inds[m_i++]) m_pass = false;
        }
    };
}


/*
 * Compile-time number of dimensions
 */
/*
 * edge case where there are no dimensions to iterate over
 */
TEST(ForeachVirtual, CtndUnrestricted0) {
    using namespace foreach_virtual_test;
    CtndUnrestricted<0> foreach({}, {});
    ASSERT_EQ(foreach.m_nterm, 0);
    foreach.loop();
    ASSERT_EQ(foreach.m_i, 0);
    ASSERT_TRUE(foreach.m_pass);
}

TEST(ForeachVirtual, CtndUnrestricted3) {
    using namespace foreach_virtual_test;
    const ctnd::inds_t<3> shape = {3, 4, 2};
    const std::vector<ctnd::inds_t<3>> chk_inds = {
            {0, 0, 0},
            {0, 0, 1},
            {0, 1, 0},
            {0, 1, 1},
            {0, 2, 0},
            {0, 2, 1},
            {0, 3, 0},
            {0, 3, 1},
            {1, 0, 0},
            {1, 0, 1},
            {1, 1, 0},
            {1, 1, 1},
            {1, 2, 0},
            {1, 2, 1},
            {1, 3, 0},
            {1, 3, 1},
            {2, 0, 0},
            {2, 0, 1},
            {2, 1, 0},
            {2, 1, 1},
            {2, 2, 0},
            {2, 2, 1},
            {2, 3, 0},
            {2, 3, 1}
    };
    CtndUnrestricted<3> foreach(shape, chk_inds);
    foreach.loop();
    ASSERT_EQ(foreach.m_i, foreach.m_nterm);
    ASSERT_TRUE(foreach.m_pass);
}

TEST(ForeachVirtual, CtndUnrestrictedExit) {
    using namespace foreach_virtual_test;
    const ctnd::inds_t<3> shape = {2, 2, 2};
    const std::vector<ctnd::inds_t<3>> chk_inds = {
            {0,0, 0},
            {0,0, 1},
            {0,1, 0},
            {0,1, 1},
            {1,0, 0},
            {1,0, 1},
            {1,1, 0},
            {1,1, 1},
    };
    struct Foreach : CtndUnrestricted<3> {
        ctnd::inds_t<3> m_term_inds;

        Foreach(ctnd::inds_t<3> shape, ctnd::inds_t<3> term_inds) :
                CtndUnrestricted<3>(shape, {}), m_term_inds(term_inds) {}

        void body(const ctnd::inds_t<3> &inds) override {
            if (inds == m_term_inds) throw ExitLoop();
            ++m_i;
        }
    };
    for (size_t i = 0ul; i < chk_inds.size(); ++i) {
        Foreach foreach(shape, chk_inds[i]);
        foreach.loop();
        // should have terminated on item i
        ASSERT_EQ(foreach.m_i, i);
    }
}

TEST(ForeachVirtual, CtndOrderedStrictAsc0) {
    using namespace foreach_virtual_test;
    CtndOrdered<0, true, true> foreach(0, {});
    ASSERT_EQ(foreach.m_nterm, 0);
    foreach.loop();
    ASSERT_EQ(foreach.m_i, 0);
    ASSERT_TRUE(foreach.m_pass);
}

TEST(ForeachVirtual, CtndOrderedStrictAsc3) {
    using namespace foreach_virtual_test;
    const size_t n = 5;
    const std::vector<ctnd::inds_t<3>> chk_inds = {
            {0, 1, 2},
            {0, 1, 3},
            {0, 2, 3},
            {1, 2, 3},
            {0, 1, 4},
            {0, 2, 4},
            {1, 2, 4},
            {0, 3, 4},
            {1, 3, 4},
            {2, 3, 4}
    };
    CtndOrdered<3, true, true> foreach(n, chk_inds);
    foreach.loop();
    ASSERT_EQ(foreach.m_i, foreach.m_nterm);
    ASSERT_TRUE(foreach.m_pass);
}

TEST(ForeachVirtual, CtndOrderedExit) {
    using namespace foreach_virtual_test;
    const size_t n = 5;
    const std::vector<ctnd::inds_t<3>> chk_inds = {
            {0, 1, 2},
            {0, 1, 3},
            {0, 2, 3},
            {1, 2, 3},
            {0, 1, 4},
            {0, 2, 4},
            {1, 2, 4},
            {0, 3, 4},
            {1, 3, 4},
            {2, 3, 4}
    };

    struct Foreach : CtndOrdered<3, true, true> {
        ctnd::inds_t<3> m_term_inds;

        Foreach(size_t n, ctnd::inds_t<3> term_inds) :
                CtndOrdered<3, true, true>(n, {}), m_term_inds(term_inds) {}

        void body(const ctnd::inds_t<3> &inds) override {
            if (inds == m_term_inds) throw ExitLoop();
            ++m_i;
        }
    };
    for (size_t i = 0ul; i < chk_inds.size(); ++i) {
        Foreach foreach(n, chk_inds[i]);
        foreach.loop();
        // should have terminated on item i
        ASSERT_EQ(foreach.m_i, i);
    }
}

TEST(ForeachVirtual, CtndOrderedStrictDesc0) {
    using namespace foreach_virtual_test;
    CtndOrdered<0, true, false> foreach(0, {});
    ASSERT_EQ(foreach.m_nterm, 0);
    foreach.loop();
    ASSERT_EQ(foreach.m_i, 0);
    ASSERT_TRUE(foreach.m_pass);
}

TEST(ForeachVirtual, CtndOrderedStrictDesc3) {
    using namespace foreach_virtual_test;
    const size_t n = 5;
    const std::vector<ctnd::inds_t<3>> chk_inds = {
            {2, 1, 0},
            {3, 1, 0},
            {3, 2, 0},
            {3, 2, 1},
            {4, 1, 0},
            {4, 2, 0},
            {4, 2, 1},
            {4, 3, 0},
            {4, 3, 1},
            {4, 3, 2}
    };
    CtndOrdered<3, true, false> foreach(n, chk_inds);
    foreach.loop();
    ASSERT_EQ(foreach.m_i, foreach.m_nterm);
    ASSERT_TRUE(foreach.m_pass);
}

TEST(ForeachVirtual, CtndOrderedAsc0) {
    using namespace foreach_virtual_test;
    CtndOrdered<0, false, true> foreach(0, {});
    ASSERT_EQ(foreach.m_nterm, 0);
    foreach.loop();
    ASSERT_EQ(foreach.m_i, 0);
    ASSERT_TRUE(foreach.m_pass);
}

TEST(ForeachVirtual, CtndOrderedAsc3) {
    using namespace foreach_virtual_test;
    const size_t n = 3;
    const std::vector<ctnd::inds_t<3>> chk_inds = {
            {0, 0, 0},
            {0, 0, 1},
            {0, 1, 1},
            {1, 1, 1},
            {0, 0, 2},
            {0, 1, 2},
            {1, 1, 2},
            {0, 2, 2},
            {1, 2, 2},
            {2, 2, 2}
    };
    CtndOrdered<3, false, true> foreach(n, chk_inds);
    foreach.loop();
    ASSERT_EQ(foreach.m_i, foreach.m_nterm);
    ASSERT_TRUE(foreach.m_pass);
}

TEST(ForeachVirtual, CtndOrderedDesc0) {
    using namespace foreach_virtual_test;
    CtndOrdered<0, false, false> foreach(0, {});
    ASSERT_EQ(foreach.m_nterm, 0);
    foreach.loop();
    ASSERT_EQ(foreach.m_i, 0);
    ASSERT_TRUE(foreach.m_pass);
}

TEST(ForeachVirtual, CtndOrderedDesc3) {
    using namespace foreach_virtual_test;
    const size_t n = 3;
    const std::vector<ctnd::inds_t<3>> chk_inds = {
            {0, 0, 0},
            {1, 0, 0},
            {1, 1, 0},
            {1, 1, 1},
            {2, 0, 0},
            {2, 1, 0},
            {2, 1, 1},
            {2, 2, 0},
            {2, 2, 1},
            {2, 2, 2}
    };
    CtndOrdered<3, false, false> foreach(n, chk_inds);
    foreach.loop();
    ASSERT_EQ(foreach.m_i, foreach.m_nterm);
    ASSERT_TRUE(foreach.m_pass);
}

#if 0

/*
 * Run-time number of dimensions
 */


/**
 * edge case where there are no dimensions to iterate over
 */
TEST(ForeachVirtual, RtndUnrestricted0) {
    const std::vector<size_t> shape = {};
    foreach_virtual::rtnd::CtndUnrestricted foreach(shape);
    size_t i = 0ul;
    auto fn = [&]() { ++i; };
    foreach(fn);
    ASSERT_EQ(i, 0);
    ASSERT_EQ(foreach.m_nterm, 0);
}

TEST(ForeachVirtual, RtndUnrestricted3) {
    const std::vector<size_t> shape = {3, 4, 2};
    const std::vector<std::vector<size_t>> chk_inds = {
            {0, 0, 0},
            {0, 0, 1},
            {0, 1, 0},
            {0, 1, 1},
            {0, 2, 0},
            {0, 2, 1},
            {0, 3, 0},
            {0, 3, 1},
            {1, 0, 0},
            {1, 0, 1},
            {1, 1, 0},
            {1, 1, 1},
            {1, 2, 0},
            {1, 2, 1},
            {1, 3, 0},
            {1, 3, 1},
            {2, 0, 0},
            {2, 0, 1},
            {2, 1, 0},
            {2, 1, 1},
            {2, 2, 0},
            {2, 2, 1},
            {2, 3, 0},
            {2, 3, 1}
    };
    foreach_virtual::rtnd::CtndUnrestricted foreach(shape);
    size_t i = 0ul;
    auto fn = [&]() { ASSERT_EQ(foreach.inds(), chk_inds[i++]); };
    foreach(fn);
    ASSERT_EQ(i, foreach.m_nterm);
}

TEST(ForeachVirtual, RtndOrderedStrictAsc0) {
    const size_t n = 5;
    foreach_virtual::rtnd::Ordered<true, true> foreach(n, 0);
    size_t i = 0ul;
    auto fn = [&]() { ++i; };
    foreach(fn);
    ASSERT_EQ(i, 0ul);
    ASSERT_EQ(foreach.m_nterm, 0ul);
}

TEST(ForeachVirtual, RtndOrderedStrictAsc3) {
    const size_t n = 5;
    foreach_virtual::rtnd::Ordered<true, true> foreach(n, 3);
    const std::vector<std::vector<size_t>> chk_inds = {
            {0, 1, 2},
            {0, 1, 3},
            {0, 2, 3},
            {1, 2, 3},
            {0, 1, 4},
            {0, 2, 4},
            {1, 2, 4},
            {0, 3, 4},
            {1, 3, 4},
            {2, 3, 4}
    };
    size_t i = 0ul;
    auto fn = [&]() { ASSERT_EQ(foreach.inds(), chk_inds[i++]); };
    foreach(fn);
    ASSERT_EQ(i, foreach.m_nterm);
}

TEST(ForeachVirtual, RtndOrderedStrictDesc0) {
    const size_t n = 5;
    foreach_virtual::rtnd::Ordered<true, false> foreach(n, 0);
    size_t i = 0ul;
    auto fn = [&]() { ++i; };
    foreach(fn);
    ASSERT_EQ(i, 0ul);
    ASSERT_EQ(foreach.m_nterm, 0ul);
}

TEST(ForeachVirtual, RtndOrderedStrictDesc3) {
    const size_t n = 5;
    foreach_virtual::rtnd::Ordered<true, false> foreach(n, 3);
    const std::vector<std::vector<size_t>> chk_inds = {
            {2, 1, 0},
            {3, 1, 0},
            {3, 2, 0},
            {3, 2, 1},
            {4, 1, 0},
            {4, 2, 0},
            {4, 2, 1},
            {4, 3, 0},
            {4, 3, 1},
            {4, 3, 2}
    };
    size_t i = 0ul;
    auto fn = [&]() { ASSERT_EQ(foreach.inds(), chk_inds[i++]); };
    foreach(fn);
    ASSERT_EQ(i, foreach.m_nterm);
}

TEST(ForeachVirtual, RtndOrderedAsc0) {
    const size_t n = 5;
    foreach_virtual::rtnd::Ordered<false, true> foreach(n, 0);
    size_t i = 0ul;
    auto fn = [&]() { ++i; };
    foreach(fn);
    ASSERT_EQ(i, 0ul);
    ASSERT_EQ(foreach.m_nterm, 0ul);
}

TEST(ForeachVirtual, RtndOrderedAsc3) {
    const size_t n = 3;
    foreach_virtual::rtnd::Ordered<false, true> foreach(n, 3);
    const std::vector<std::vector<size_t>> chk_inds = {
            {0, 0, 0},
            {0, 0, 1},
            {0, 1, 1},
            {1, 1, 1},
            {0, 0, 2},
            {0, 1, 2},
            {1, 1, 2},
            {0, 2, 2},
            {1, 2, 2},
            {2, 2, 2}
    };
    size_t i = 0ul;
    auto fn = [&]() { ASSERT_EQ(foreach.inds(), chk_inds[i++]); };
    foreach(fn);
    ASSERT_EQ(i, foreach.m_nterm);
}

TEST(ForeachVirtual, RtndOrderedDesc0) {
    const size_t n = 5;
    foreach_virtual::rtnd::Ordered<false, false> foreach(n, 0);
    size_t i = 0ul;
    auto fn = [&]() { ++i; };
    foreach(fn);
    ASSERT_EQ(i, 0ul);
    ASSERT_EQ(foreach.m_nterm, 0ul);
}

TEST(ForeachVirtual, RtndOrderedDesc3) {
    const size_t n = 3;
    foreach_virtual::rtnd::Ordered<false, false> foreach(n, 3);
    const std::vector<std::vector<size_t>> chk_inds = {
            {0, 0, 0},
            {1, 0, 0},
            {1, 1, 0},
            {1, 1, 1},
            {2, 0, 0},
            {2, 1, 0},
            {2, 1, 1},
            {2, 2, 0},
            {2, 2, 1},
            {2, 2, 2}
    };
    size_t i = 0ul;
    auto fn = [&]() { ASSERT_EQ(foreach.inds(), chk_inds[i++]); };
    foreach(fn);
    ASSERT_EQ(i, foreach.m_nterm);
}
#endif