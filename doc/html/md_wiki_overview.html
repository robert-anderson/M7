<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>M7: Wiki</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
   TeX: { Macros: {
    bfi: "{\\mathbf{i}}",
    Ci: "{C_\\bfi}",
    Cin: "{C_{\\bfi(n)}}",
    Cinext: "{C_{\\bfi(n+1)}}",
    bfj: "{\\mathbf{j}}",
    Cj: "{C_\\bfj}",
    Cjn: "{C_{\\bfj(n)}}",
    Cjnext: "{C_{\\bfj(n+1)}}",
    Hop: "{\\hat{H}}",
    Hii: "{H_{\\bfi\\bfi}}",
    Hjj: "{H_{\\bfj\\bfj}}",
    Hij: "{H_{\\bfi\\bfj}}",
    Hji: "{H_{\\bfj\\bfi}}",
    Di: "{D_\\bfi}",
    Dj: "{D_\\bfj}",
    ketDi: "{|D_\\bfi\\rangle}",
    ketDj: "{|D_\\bfj\\rangle}",
    braDi: "{\\langle D_\\bfi|}",
    braDj: "{\\langle D_\\bfj|}",
    ketPsi: "{|\\Psi\\rangle}",
    ketPsin: "{|\\Psi_{(n)}\\rangle}",
    ketPsinext: "{|\\Psi_{(n+1)}\\rangle}",
    braPsi: "{\\langle\\Psi|}",
    braPsin: "{\\langle\\Psi_{(n)}|}",
    braPsinext: "{\\langle\\Psi_{(n+1)}|}",
    dspawnn: "{\\Delta^\\mathrm{spawn}_{\\bfi(n)}}",
    ddeathn: "{\\Delta^\\mathrm{death}_{\\bfi(n)}}",
  } }
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">M7
   </div>
   <div id="projectbrief">A hybrid-parallelized and object-oriented stochastic electronic structure program</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Wiki </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>M7 (<em>Many-body Stochastic Expectation Value Estimation Networks</em>) is a stochastic quantum chemistry software package which primarily implements the FCIQMC method <a class="el" href="citelist.html#CITEREF_doi:10.1063/1.3193710">[1]</a>. The purpose of this wiki is to provide a space in which M7 users and developers can learn from and contribute to a body of knowledge, advice, and best practices accumulated over the entire lifetime of this project.</p>
<h1><a class="anchor" id="autotoc_md4"></a>
FCIQMC Algorithm</h1>
<p>The FCIQMC method is founded on the assumption that stochastic application of the projector method recursion relation </p><p class="formulaDsp">
\[ \label{eq:master} \ketPsinext = (1-\tau\Hop)\ketPsin \]
</p>
<p> with a suitably small <em>timestep</em> \(\tau\), where the <a class="el" href="classWavefunction.html">Wavefunction</a> is a linear superposition of Slater determinants </p><p class="formulaDsp">
\[ \label{eq:psidef} \ketPsi \equiv \sum_\bfi \Ci \ketDi \]
</p>
<p> can yield accurate eigenvalues and other properties for configuration-interation problems far beyond the scope of exact diagonalisation methods.</p>
<p>This delay in the onset of the "curse of dimensionality" faced by exponentially-scaling correlation methods is achieved by discretising the \(\Ci\) coefficients as a population of <em>walkers</em>. Thus, at any given iteration of \(\eqref{eq:master}\), the number of determinants with any walker occupation is usually a shrinking minority of the total dimension of the space (provided that a single particle basis conducive to this sparsity e.g. the canonical Hartree-Fock orbitals is chosen). By this approach, the memory scaling of the FCI problem can be brought within practicable limits, provided that an efficient system of data structures can be devised to store and update a sparse, parallelised representation of \(\ketPsi\)</p>
<p>Computational tractability is also aided by the walker discretisation, since the accumulation of walkers on a given determinant indicates the number of attempts the algorithm should make to convey new walkers from that source. The processes by which the \(\Ci\) coefficients are updated are called <em>spawning</em> (off-diagonal elements), and <em>death</em> (off-diagonal elements) </p><p class="formulaDsp">
\[ \Cinext = \Cin - \tau \sum_{\bfj\neq\bfi} \Hij \Cjn - \tau(\Hii - S) \Cin \]
</p>
<p> where \(S\) is an approximation to the exact ground-state eigenvalue called the <em>diagonal shift</em>. In the expression of the FCIQMC algorithm, it is convenient to use the following notation </p><p class="formulaDsp">
\[ \Cinext \equiv \Cin + \dspawnn + \ddeathn \]
</p>
<p>Structurally, the FCIQMC code is contained within a <a class="el" href="classFciqmcCalculation.html">FciqmcCalculation</a> object, which serves as a high-level class tying together the more intricate objects in the implementation. One such crucial object is the <a class="el" href="classWavefunction.html">Wavefunction</a>, which in turn contains a system of three central <a class="el" href="classList.html">List</a> objects: namely a <a class="el" href="structWalkerList.html">WalkerList</a> &mdash; which records the state of the discretised \(\ketPsin\) at an iteration \(n\), and two <a class="el" href="structSpawnList.html">SpawnList</a> objects &mdash; which are responsible for the MPI-based communication of stochastically-generated off-diagonal Monte Carlo moves.</p>
<h2><a class="anchor" id="autotoc_md5"></a>
Spawning and Death</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">walker list </th><th class="markdownTableHeadNone">send buffer </th><th class="markdownTableHeadNone">receive buffer  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">\(\Cin\) </td><td class="markdownTableBodyNone">\(0\) </td><td class="markdownTableBodyNone">\(0\)  </td></tr>
</table>
<p>The walker list is sequentially accessed, with each <em>source</em> <a class="el" href="classDeterminant.html">Determinant</a> \(\Dj\) selecting zero or more <em>destination</em> determinants through an <a class="el" href="classExcitationGenerator.html">ExcitationGenerator</a>. The instantaneous walker weight on \(\Dj\) is conveyed as the ratio of \(\Cjn\) to the number of attempts made to generate a connected \(\Di\). The death contribution is taken into account in the same loop after all spawns have been generated. </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">walker list </th><th class="markdownTableHeadNone">send buffer </th><th class="markdownTableHeadNone">receive buffer  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">\(\Cin+\ddeathn\) </td><td class="markdownTableBodyNone">\(\dspawnn\) </td><td class="markdownTableBodyNone">\(0\)  </td></tr>
</table>
<p>at the end of this loop over occupied determinants, the walker list reflects only the update to the approximate wavefunction due to the diagonal part of the shifted <a class="el" href="classHamiltonian.html">Hamiltonian</a>.</p>
<h2><a class="anchor" id="autotoc_md6"></a>
Communication</h2>
<p>The generated spawns have been enumerated in a segmented <a class="el" href="classList.html">List</a>, with the segment corresponding to the id of the MPI rank due to receive the spawned contribution. This rank is decided on a determinant block-by determinant block basis through a <a class="el" href="classRankAllocator.html">RankAllocator</a>, which can dynamically reallocate determinant blocks between MPI ranks an effort to eliminate performance stifling load imbalance.</p>
<p>Sent spawns are scattered by and gathered to every process via the MPI_Alltoallv subroutine.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">walker list </th><th class="markdownTableHeadNone">send buffer </th><th class="markdownTableHeadNone">receive buffer  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">\(\Cin+\ddeathn\) </td><td class="markdownTableBodyNone">\(0\) </td><td class="markdownTableBodyNone">\(\dspawnn\)  </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md7"></a>
Annihilation</h2>
<p>This step is a sequential access on the incoming spawned contributions, resulting in random access update of the walker list by hash table lookup.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">walker list </th><th class="markdownTableHeadNone">send buffer </th><th class="markdownTableHeadNone">receive buffer  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">\(\Cinext\) </td><td class="markdownTableBodyNone">\(0\) </td><td class="markdownTableBodyNone">\(0\)  </td></tr>
</table>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.18
</small></address>
</body>
</html>
